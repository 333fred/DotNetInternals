@page "/"
@implements IDisposable
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

<PageTitle>Lab • DotNetInternals</PageTitle>

<div class="row align-items-center justify-content-center my-1 w-100">
    @* App name / link *@
    <div class="col-auto">
        <a href="/" class="text-decoration-none">lab.razor.fyi</a>
        (<a href="https://github.com/jjonescz/DotNetInternals">GitHub</a>)
    </div>

    @* Input tabs *@
    <div class="col-auto">
        @if (SimpleMode)
        {
            <div class="btn-toolbar" role="toolbar" title="Input">
                @* C# / Razor switch *@
                <InputRadioGroup @bind-Value:get="SelectedSimpleInput" @bind-Value:set="OnSelectSimpleInputAsync">
                    <div class="btn-group me-2" role="group" title="Input type">
                        <InputRadio class="btn-check" id="inputCSharp" Value="@SpecialInput.AddCSharp" />
                        <label class="btn btn-outline-primary" for="inputCSharp">
                            C#
                        </label>

                        <InputRadio class="btn-check" id="inputRazor" Value="@SpecialInput.AddRazor" />
                        <label class="btn btn-outline-primary" for="inputRazor">
                            Razor
                        </label>
                    </div>
                </InputRadioGroup>

                <div class="btn-group">
                    <button type="button" class="btn btn-outline-secondary"
                            title="Add more input files"
                            @onclick="() => forceAdvancedMode = true">
                        @BootstrapIcons.PlusLg
                    </button>
                </div>
            </div>
        }
        else
        {
            <div class="input-group">
                @if (CurrentInput != null && renamingTo != null)
                {
                    @* Renaming confirmation *@
                    <input type="text" class="form-control" placeholder="@CurrentInput.FileName" title="File name" @bind="renamingTo" />
                    <button type="button" class="btn btn-outline-primary" title="Confirm rename"
                            @onclick="RenameInputAsync">
                        @BootstrapIcons.CheckLg
                    </button>
                    <button type="button" class="btn btn-outline-secondary" title="Cancel rename"
                            @onclick="() => renamingTo = null">
                        @BootstrapIcons.XLg
                    </button>
                }
                else
                {
                    @* Input tabs *@
                    <select class="form-select" title="Input file" @bind:get="currentInputIndex" @bind:set="OnInputSelectedAsync">
                        @foreach (var (index, input) in inputs.Index())
                        {
                            <option value="@index">
                                @input.FileName
                            </option>
                        }
                        <hr />
                        <option value="@((int)SpecialInput.AddRazor)">
                            Add .razor
                        </option>
                        <option value="@((int)SpecialInput.AddCSharp)">
                            Add .cs
                        </option>
                        @if (inputs.Count > 1)
                        {
                            <hr />
                            <option value="@((int)SpecialInput.CloseOtherTabs)">
                                Close other tabs
                            </option>
                        }
                    </select>

                    @if (CurrentInput != null)
                    {
                        @* Rename button *@
                        <button type="button" class="btn btn-outline-secondary" title="Rename current file"
                                @onclick="() => renamingTo = CurrentInput.FileName">
                            @BootstrapIcons.Pencil
                        </button>

                        @* Delete button *@
                        if (inputs.Count > 1)
                        {
                            <button type="button" class="btn btn-outline-danger" title="Delete current file"
                                    @onclick="DeleteInputAsync">
                                @BootstrapIcons.Trash3
                            </button>
                        }
                    }
                }
            </div>
        }
    </div>

    @* Compile button *@
    <div class="col-auto">
        <button type="button" class="btn btn-primary" @onclick="CompileAsync">
            Compile
            @if (compilationInProgress)
            {
                <div class="spinner-border spinner-border-sm ms-2" role="status">
                    <span class="visually-hidden">Compiling...</span>
                </div>
            }
        </button>
    </div>

    @* Output switch *@
    @if (compiled != null)
    {
        <InputRadioGroup @bind-Value="selectedOutputType">
            <div class="btn-group col-auto" role="group" title="Output type">
                @foreach (var output in CurrentCompiledFile?.Outputs ?? [])
                {
                    var id = $"output{output.Type}";
                    <InputRadio class="btn-check" id="@id" Value="@output.Type" />
                    <label class="btn btn-outline-primary" for="@id">
                        @output.Type
                    </label>
                }

                <InputRadio class="btn-check" id="outputDiagnostics" Value="diagnosticsOutputType" />
                <label class="btn btn-outline-primary" for="outputDiagnostics">
                    Error List
                    @if (compiled?.NumErrors > 0)
                    {
                        <span class="badge bg-danger">@compiled.NumErrors</span>
                    }
                    else if (compiled?.NumWarnings > 0)
                    {
                        <span class="badge bg-warning">@compiled.NumWarnings</span>
                    }
                </label>
            </div>
        </InputRadioGroup>
    }

    @* Settings button *@
    <div class="col-auto">
        <Settings @ref="settings" Editor="inputEditor" @bind-WordWrap="wordWrap" @bind-UseVim="useVim" />
    </div>
</div>

@* Input / output text areas *@
@{
    var textAreaClass = $"form-control h-100 flex-grow-1 {(wordWrap ? "" : "no-wrap")}";
}
<div class="row g-0 flex-grow-1">
    <div class="col d-flex flex-column">
        <div id="vim-status" class="vim-status-bar" hidden="@(!useVim)" />
        <div class="flex-grow-1">
            <BlazorMonaco.Editor.StandaloneCodeEditor @ref="inputEditor" Id="input-editor"
                ConstructionOptions="EditorConstructionOptions" OnDidInit="EditorInitAsync" />
        </div>
    </div>
    <div class="col">
        <textarea value="@Output" class="@textAreaClass" readonly placeholder="Empty output (click Compile to refresh)" spellcheck="false"></textarea>
    </div>
</div>

@code {
    private const string diagnosticsOutputType = "Diagnostics";

    private readonly List<Input> inputs = new();
    private int currentInputIndex;
    private string? renamingTo;
    private bool forceAdvancedMode;
    private StandaloneCodeEditor inputEditor = null!;
    private string? selectedOutputType;
    private bool compilationInProgress;
    private CompiledAssembly? compiled;
    private Settings settings = null!;
    private bool wordWrap;
    private bool useVim;

    private sealed record Input(string FileName, TextModel Model)
    {
        public string FileName { get; set; } = FileName;
    }

    private enum SpecialInput
    {
        AddRazor = -1,
        AddCSharp = -2,
        CloseOtherTabs = -3,
    }

    private Input? CurrentInput
    {
        get
        {
            if (currentInputIndex < 0 || currentInputIndex >= inputs.Count)
            {
                return null;
            }

            return inputs[currentInputIndex];
        }
    }

    /// <summary>
    /// In simple mode, there is just one tab with either Razor or C# code.
    /// </summary>
    private bool SimpleMode
    {
        get
        {
            if (forceAdvancedMode || inputs is not [var input])
            {
                return false;
            }

            var fileName = input.FileName;
            return fileName == Compiler.InitialRazorCode.SuggestedFileName ||
                fileName == Compiler.InitialCSharpCode.SuggestedFileName;
        }
    }

    private SpecialInput SelectedSimpleInput
    {
        get
        {
            return CurrentInput?.FileName == Compiler.InitialRazorCode.SuggestedFileName
                ? SpecialInput.AddRazor
                : SpecialInput.AddCSharp;
        }
    }

    protected override void OnInitialized()
    {
        NavigationManager.LocationChanged += OnLocationChanged;
    }

    void IDisposable.Dispose()
    {
        NavigationManager.LocationChanged -= OnLocationChanged;
    }

    private async void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        await LoadInputStateFromUrlAsync();
        StateHasChanged();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        // Select an output type if none is selected.
        if (selectedOutputType != diagnosticsOutputType &&
            CurrentCompiledFile?.Outputs.Length > 0 &&
            (selectedOutputType == null || CurrentCompiledFile.GetOutput(selectedOutputType) == null))
        {
            selectedOutputType = CurrentCompiledFile.Outputs.MaxBy(static o => o.Priority)!.Type;
            StateHasChanged();
        }
    }

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            WordWrap = wordWrap ? "on" : "off",
        };
    }

    private async Task OnInputSelectedAsync(int selectedInputIndex)
    {
        await SaveInputStateToUrlAsync();

        switch (selectedInputIndex)
        {
            case (int)SpecialInput.AddRazor:
                await AddInputAsync(Compiler.InitialRazorCode);
                break;

            case (int)SpecialInput.AddCSharp:
                await AddInputAsync(Compiler.InitialCSharpCode);
                break;

            case (int)SpecialInput.CloseOtherTabs:
                inputs.RemoveAll(i => i != CurrentInput);
                forceAdvancedMode = true;
                currentInputIndex = 0;
                break;

            case var _ when selectedInputIndex >= 0 && selectedInputIndex < inputs.Count:
                currentInputIndex = selectedInputIndex;
                await inputEditor.SetModel(inputs[selectedInputIndex].Model);
                break;
        }

        await SaveInputStateToUrlAsync();
    }

    private async Task OnSelectSimpleInputAsync(SpecialInput input)
    {
        Debug.Assert(SimpleMode && inputs.Count == 1);

        await SaveInputStateToUrlAsync();

        inputs.Clear();
        await AddInputAsync(input == SpecialInput.AddRazor
            ? Compiler.InitialRazorCode
            : Compiler.InitialCSharpCode);
        Debug.Assert(SimpleMode);

        await SaveInputStateToUrlAsync();
    }

    private async Task RenameInputAsync()
    {
        Debug.Assert(CurrentInput != null && renamingTo != null);

        await SaveInputStateToUrlAsync();

        if (CurrentInput.FileName != renamingTo)
        {
            var oldLanguage = GetLanguageForFileExtension(Path.GetExtension(CurrentInput.FileName));
            var newLanguage = GetLanguageForFileExtension(Path.GetExtension(renamingTo));

            CurrentInput.FileName = renamingTo;

            if (oldLanguage != newLanguage)
            {
                await BlazorMonaco.Editor.Global.SetModelLanguage(JSRuntime, CurrentInput.Model, newLanguage);
            }
        }
        renamingTo = null;

        await SaveInputStateToUrlAsync();
    }

    private async Task DeleteInputAsync()
    {
        Debug.Assert(CurrentInput != null && inputs.Count > 1);

        await SaveInputStateToUrlAsync();

        inputs.RemoveAt(currentInputIndex);
        currentInputIndex = 0;
        await inputEditor.SetModel(CurrentInput.Model);

        await SaveInputStateToUrlAsync();
    }

    private async Task AddInputAsync(InitialCode initialCode)
    {
        var fileName = FindUniqueName(initialCode);
        var inputCode = initialCode.ToInputCode(fileName);
        var model = await CreateModelAsync(inputCode);
        inputs.Add(new(fileName, model));
        currentInputIndex = inputs.Count - 1;
        await inputEditor.SetModel(model);
    }

    private string FindUniqueName(InitialCode initialCode)
    {
        for (var i = 0; ; i++)
        {
            var suffix = i == 0 ? "" : $"{i}";
            var fileName = initialCode.GetFinalFileName(suffix);
            if (!inputs.Any(i => i.FileName == fileName))
            {
                return fileName;
            }
        }
    }

    private async Task CompileAsync()
    {
        compilationInProgress = true;

        var inputCodes = await GetInputCodesAsync();

        SaveInputStateToUrl(inputCodes);

        await RefreshAsync();

        // Compile.
        compiled = await Compiler.CompileAsync(inputCodes);

        compilationInProgress = false;
    }

    private string Output => selectedOutputType switch
    {
        _ when compiled is null => "",
        null => "",
        diagnosticsOutputType => compiled.Diagnostics,
        var other => CurrentCompiledFile?.GetOutput(other) ?? "",
    };

    private CompiledFile? CurrentCompiledFile
    {
        get
        {
            return compiled?.Files.TryGetValue(CurrentInput?.FileName ?? "", out var file) == true
                ? file
                : null;
        }
    }

    private async Task EditorInitAsync()
    {
        await settings.InitializeAsync();

        await LoadInputStateFromUrlAsync();
    }

    private string GetCurrentSlug()
    {
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        return uri.Fragment.TrimStart('#');
    }

    private async Task LoadInputStateFromUrlAsync()
    {
        var slug = GetCurrentSlug();

        inputs.Clear();
        currentInputIndex = 0;

        if (string.IsNullOrWhiteSpace(slug))
        {
            await AddInputAsync(Compiler.InitialRazorCode);
        }
        else
        {
            var savedState = Compressor.Uncompress(slug);
            foreach (var (index, input) in savedState.Inputs.Index())
            {
                var model = await CreateModelAsync(input);
                inputs.Add(new(input.FileName, model));

                if (index == 0)
                {
                    await inputEditor.SetModel(model);
                }
            }
        }
    }

    private async Task<ImmutableArray<InputCode>> GetInputCodesAsync()
    {            
        var builder = ImmutableArray.CreateBuilder<InputCode>(inputs.Count);
        foreach (var (fileName, model) in inputs)
        {
            var text = await model.GetValue(EndOfLinePreference.TextDefined, preserveBOM: true);
            builder.Add(new() { FileName = fileName, Text = text });
        }
        return builder.ToImmutable();
    }

    private async Task SaveInputStateToUrlAsync()
    {
        SaveInputStateToUrl(await GetInputCodesAsync());
    }

    private void SaveInputStateToUrl(ImmutableArray<InputCode> inputCodes)
    {
        var currentSlug = GetCurrentSlug();
        var newSlug = Compressor.Compress(new SavedState { Inputs = inputCodes });
        if (newSlug != currentSlug)
        {
            NavigationManager.NavigateTo(NavigationManager.BaseUri + "#" + newSlug, forceLoad: false);
        }
    }

    private async Task<TextModel> CreateModelAsync(InputCode inputCode)
    {
        return await BlazorMonaco.Editor.Global.CreateModel(
            JSRuntime,
            value: inputCode.Text,
            language: GetLanguageForFileExtension(inputCode.FileExtension));
    }

    private static string? GetLanguageForFileExtension(string extension) => extension switch
    {
        ".razor" or ".cshtml" => "razor",
        ".cs" => "csharp",
        _ => null,
    };
}
