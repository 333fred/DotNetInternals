@page "/"
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager

<PageTitle>Razor • DotNetInternals</PageTitle>

<div class="row align-items-center justify-content-center my-1 w-100">
    @* App name / link *@
    <div class="col-auto">
        <a href="/" class="text-decoration-none">lab.razor.fyi</a>
        (<a href="https://github.com/jjonescz/DotNetInternals">GitHub</a>)
    </div>

    @* Tab select *@
    <div class="col-auto">
        <select class="form-select" title="Input file" @bind:get="currentInput" @bind:set="OnInputSelectedAsync">
            @foreach (var fileName in inputs.Keys)
            {
                <option value="@fileName">
                    @fileName
                </option>
            }
            <hr />
            <option value="@FindUniqueName(RazorCompiler.InitialRazorCode)">
                Add .razor
            </option>
            <option value="@FindUniqueName(RazorCompiler.InitialCSharpCode)">
                Add .cs
            </option>
        </select>
    </div>

    @* Compile button *@
    <div class="col-auto">
        <button type="button" class="btn btn-primary" @onclick="CompileAsync">
            Compile
            @if (compilationInProgress)
            {
                <div class="spinner-border spinner-border-sm ms-2" role="status">
                    <span class="visually-hidden">Compiling...</span>
                </div>
            }
        </button>
    </div>

    @* Output switch *@
    <InputRadioGroup @bind-Value="SelectedOutputType">
        <div class="btn-group col-auto" role="group" aria-label="Output type">
            <InputRadio class="btn-check" id="outputSyntax" Value="OutputType.Syntax" />
            <label class="btn btn-outline-primary" for="outputSyntax">
                Syntax
            </label>

            <InputRadio class="btn-check" id="outputIr" Value="OutputType.Ir" />
            <label class="btn btn-outline-primary" for="outputIr">
                IR
            </label>

            <InputRadio class="btn-check" id="outputCSharp" Value="OutputType.CSharp" />
            <label class="btn btn-outline-primary" for="outputCSharp">
                C#
            </label>

            <InputRadio class="btn-check" id="outputDiagnostics" Value="OutputType.Diagnostics" />
            <label class="btn btn-outline-primary" for="outputDiagnostics">
                Diagnostics
                @if (compiled?.NumErrors > 0)
                {
                    <span class="badge bg-danger">@compiled.NumErrors</span>
                }
                else if (compiled?.NumWarnings > 0)
                {
                    <span class="badge bg-warning">@compiled.NumWarnings</span>
                }
            </label>
        </div>
    </InputRadioGroup>

    @* Settings button *@
    <div class="col-auto">
        <Settings @ref="settings" Editor="razorCode" @bind-WordWrap="wordWrap" @bind-UseVim="useVim" />
    </div>
</div>

@* Input / output text areas *@
@{
    var textAreaClass = $"form-control h-100 flex-grow-1 {(wordWrap ? "" : "no-wrap")}";
}
<div class="row g-0 flex-grow-1">
    <div class="col d-flex flex-column">
        <div id="vim-status" class="vim-status-bar" hidden="@(!useVim)" />
        <div class="flex-grow-1">
            <BlazorMonaco.Editor.StandaloneCodeEditor @ref="razorCode" Id="razor-code"
                ConstructionOptions="EditorConstructionOptions" OnDidInit="EditorInitAsync" />
        </div>
    </div>
    <div class="col">
        <textarea @bind="output" class="@textAreaClass" readonly placeholder="Empty output (click Compile to refresh)" spellcheck="false"></textarea>
    </div>
</div>

@code {
    private readonly Dictionary<string, TextModel> inputs = new();
    private string? currentInput = null;
    private StandaloneCodeEditor razorCode = null!;
    private OutputType _outputType = OutputType.CSharp;
    private bool compilationInProgress;
    private CompiledRazor? compiled;
    private string output = "";
    private Settings settings = null!;
    private bool wordWrap;
    private bool useVim;

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            WordWrap = wordWrap ? "on" : "off",
        };
    }

    private async Task OnInputSelectedAsync(string? selectedInput)
    {
        if (selectedInput is null)
        {
            currentInput = selectedInput;
            return;
        }

        if (inputs.TryGetValue(selectedInput, out var input))
        {
            currentInput = selectedInput;
            await razorCode.SetModel(input);
        }
        else if (selectedInput.EndsWith(RazorCompiler.InitialRazorCode.SuggestedFileExtension, StringComparison.Ordinal))
        {
            await AddInputAsync(RazorCompiler.InitialRazorCode);
        }
        else if (selectedInput.EndsWith(RazorCompiler.InitialCSharpCode.SuggestedFileExtension, StringComparison.Ordinal))
        {
            await AddInputAsync(RazorCompiler.InitialCSharpCode);
        }
    }

    private async Task AddInputAsync(InitialCode initialCode)
    {
        var fileName = FindUniqueName(initialCode);
        var model = await CreateModelAsync(initialCode.ToInputCode(fileName));
        inputs[fileName] = model;
        currentInput = fileName;
        await razorCode.SetModel(model);
    }

    private string FindUniqueName(InitialCode initialCode)
    {
        for (var i = 0; ; i++)
        {
            var suffix = i == 0 ? "" : $"{i}";
            var fileName = initialCode.GetFinalFileName(suffix);
            if (!inputs.ContainsKey(fileName))
            {
                return fileName;
            }
        }
    }

    private OutputType SelectedOutputType
    {
        get => _outputType;
        set
        {
            _outputType = value;
            UpdateOutput();
        }
    }

    private async Task CompileAsync()
    {
        compilationInProgress = true;

        var text = await razorCode.GetValue();

        // Save state (input code) to URL.
        var slug = Compressor.Compress(text);
        NavigationManager.NavigateTo(NavigationManager.BaseUri + "#" + slug, forceLoad: false);

        await RefreshAsync();

        compiled = RazorCompiler.Compile(text);
        UpdateOutput();

        compilationInProgress = false;
    }

    private void UpdateOutput()
    {
        output = SelectedOutputType switch
        {
            _ when compiled is null => "",
            OutputType.Syntax => compiled.Syntax,
            OutputType.Ir => compiled.Ir,
            OutputType.CSharp => compiled.CSharp,
            OutputType.Diagnostics => compiled.Diagnostics,
            _ => throw new InvalidOperationException(),
        };
    }

    private enum OutputType
    {
        Syntax,
        Ir,
        CSharp,
        Diagnostics,
    }

    private async Task EditorInitAsync()
    {
        await settings.InitializeAsync();

        // Load state (input code) from URL.
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        var slug = uri.Fragment.TrimStart('#');

        if (string.IsNullOrWhiteSpace(slug))
        {
            await AddInputAsync(RazorCompiler.InitialRazorCode);
        }
        else
        {
            var text = Compressor.Uncompress(slug);
            await razorCode.SetValue(text);
        }
    }

    private async Task<TextModel> CreateModelAsync(InputCode inputCode)
    {
        return await BlazorMonaco.Editor.Global.CreateModel(
            JSRuntime,
            value: inputCode.Text,
            language: Path.GetExtension(inputCode.FileName) switch
            {
                ".razor" => "razor",
                ".cs" => "csharp",
                _ => null,
            });
    }
}
